<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Compost Game</title>
    <style>
      .game {
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100vh;
      }

      .bins {
        display: flex;
        justify-content: center;
        width: 100%;
        margin-top: 100px;
      }

      .bin {
        height: 300px;
        width: 130px;
        background-size: contain;
        background-repeat: no-repeat;
      }

      .bin:nth-child(2) {
        margin: 0 150px;
      }

      @media only screen and (max-width: 700px) {
        .bin:nth-child(2) {
          margin: 0 50px;
        }
      }

      .trash {
        background-image: url("./images/bins/trashClosed.svg");
      }

      .recycle {
        background-image: url("./images/bins/recycleClosed.svg");
      }

      .compost {
        background-image: url("./images/bins/compostClosed.svg");
      }

      .item {
        height: 100px;
        width: 100px;
        touch-action: none;
        user-select: none;
        cursor: grab;
        background-color: transparent;
        background-size: cover;
        background-repeat: no-repeat;
      }

      .score,
      .attempted {
        align-self: flex-start;
      }

      .errorMsg {
        height: 20px;
      }

      #win-modal {
        position: fixed;
        top: 10vh;
        left: 35%;
        display: none;
        background-color: white;
      }

      #moreInfo-modal {
        top: 0;
        position: fixed;
        display: none;
        background-color: white;
      }

      #speech {
        display: block;
        position: absolute;
        bottom: 50px;
      }

      .button {
        background-color: yellow;
        padding: 10px;
      }
    </style>
  </head>

  <body>
    <div class="game">
      <div class="score"></div>
      <div class="attempted"></div>
      <button onclick="displayMoreInfo()" class="button">More Info</button>

      <p class="description"></p>
      <div class="item"></div>

      <div id="speech">
        <p>This is a placeholder</p>
      </div>

      <div class="bins">
        <div class="bin trash"></div>
        <div class="bin recycle"></div>
        <div class="bin compost"></div>
      </div>
    </div>

    <div id="win-modal">
      <p>ok good job, but can you do it again? I dare you.</p>
      <p id="final-score"></p>
      <button onclick="startOver()" class="button">Start Over</button>
      <button onclick="displayMoreInfo()" class="button">More Info</button>
      <button class="button">Download Infographic</button>
    </div>

    <div id="moreInfo-modal">
      <h1>More Info:</h1>

      <h2>Recycling:</h2>

      <ul>
        <li>Items must be clean to be recycled.</li>
        <li>
          Not all facilities accept the same items into recycling. Make sure to
          check the guidelines by your local waste treatment facility.
        </li>
        <li>
          Many recyclable items, such as batteries and grocery bags, aren’t
          accepted by curbside pickup but can be accepted by specialty recycling
          locations.
        </li>
      </ul>

      <h2>Composting:</h2>

      <ul>
        <li>
          Consider if the item is contaminated by a non-compostable material.
          For example, a clean paper towel can be composted, but if the paper
          towel was used on oils or cleaning chemicals, it should be thrown out.
        </li>
        <li>
          Consider the material that an item is made from. For example, a cotton
          tea bag may be fully compostable, but a synthetic tea bag will not be.
        </li>
        <li>
          Not all compost piles can break down the same materials. If you are
          sending compost to a large-scale compost facility, be sure to check
          what items they accept.
        </li>
        <li>
          Backyard compost piles are generally more limited, since they do not
          get as hot and are generally more susceptible to pests.
        </li>
      </ul>

      <p>
        If you’re still not sure which bin to put any item, the best thing to do
        may be to throw it away. This helps avoid contaminating a recycling or
        compost bin.
      </p>

      <p>
        Remember that the first steps in making a difference are refuse, reduce,
        and reuse. Creating less waste in the first place is better than proper
        composting and recycling.
      </p>

      <h3>Credits:</h3>
      <p>Ryan Piracha - Director, Illustrator, Developer</p>
      <p>Andrew Hinton - Developer</p>

      <button onclick="displayMoreInfo()" class="button">Close</button>
    </div>

    <script>
      // preload images
      let preloadedImages = [
        "./images/bins/trashOpen.svg",
        "./images/bins/recycleOpen.svg",
        "./images/bins/compostOpen.svg",
      ];
      let preloaded = [];
      for (let i = 0; i < preloadedImages.length; i++) {
        let preloadedImage = new Image();
        preloadedImage.src = preloadedImages[i];
        preloaded.push(preloadedImage);
      }
    </script>

    <script>
      // Declare Data
      let defaultErr = "I don't like it in there!";
      const items = {
        apple: {
          bin: "compost",
          error: defaultErr,
        },
        veggies: {
          bin: "compost",
          error: defaultErr,
        },
        coffee: {
          bin: "compost",
          error: defaultErr,
        },
        cardboard: {
          bin: "recycle",
          error:
            "Clean cardboard can be composted, but it is better to recycle it",
        },
        "fats-and-oils": {
          bin: "trash",
          error: defaultErr,
        },
        bones: {
          bin: "trash",
          error: defaultErr,
        },
        "aluminum-cans": {
          bin: "recycle",
          error: defaultErr,
        },
        "plastic-bottles": {
          bin: "recycle",
          error: defaultErr,
        },
        styrofoam: {
          bin: "trash",
          error: defaultErr,
        },
        eggshells: {
          bin: "compost",
          error: defaultErr,
        },
        "tea-leaves": {
          bin: "compost",
          error: defaultErr,
        },
        newspaper: {
          bin: "recycle",
          error: defaultErr,
        },
        "paper-towel": {
          bin: "trash",
          error: defaultErr,
        },
      };

      // DOING STUFF

      // Setup current item
      let inPlay = shuffle(Object.keys(items));
      let lastSuccess = false;
      let itemImg = document.querySelectorAll(".item")[0];
      let game = document.querySelectorAll(".game")[0];
      let itemDes = document.querySelectorAll(".description")[0];
      let itemErr = document.querySelector("#speech");
      let winModal = document.querySelector("#win-modal");
      let moreInfoModal = document.querySelector("#moreInfo-modal");
      let displayFinalScore = document.querySelector("#final-score");

      //score variables
      let score = 0;
      let attempted = 0;
      let calculatedScore = 100;
      let scoreEl = document.querySelectorAll(".score")[0];
      let attemptedEl = document.querySelectorAll(".attempted")[0];
      let totalItems = inPlay.length;
      let onItem = 1;

      // Draging variables
      let dragActive = false;
      let canDrag = true;
      let currentX, currentY, initialX, initialY;
      let offsetX = (offsetY = 0);

      // Animation Variables
      let animationStartTime;
      let animating = false;
      let animationPos = 0;
      let animationDuration = 1000;

      // GAME LOOP START
      let currentItem = inPlay[0];
      displayItem(items[currentItem], currentItem);
      displayScore();

      // Helper Functions
      function setEmotion(emotion) {
        //TODO get .item width from css for multiplication
        switch (emotion) {
          case "surprised":
            itemImg.style.backgroundPositionX = "-100px";
            break;
          case "happy":
            itemImg.style.backgroundPositionX = "-200px";
            break;
          case "sad":
            itemImg.style.backgroundPositionX = "-300px";
            break;
          default:
            itemImg.style.backgroundPositionX = "0px";
            break;
        }
      }

      function isOverlapping(rect1, rect2) {
        let padding = 10; //TODO: fuck with hitbox padding
        return !(
          rect1.right < rect2.left ||
          rect1.left > rect2.right ||
          rect1.bottom < rect2.top ||
          rect1.top > rect2.bottom
        );
      }

      function getOverlappingBin(rect) {
        const bins = document.querySelectorAll(".bin");
        for (let i = 0; i < bins.length; i++) {
          const binRect = bins[i].getBoundingClientRect();
          let binName = bins[i].classList.toString().replace("bin", "").trim();
          if (isOverlapping(rect, binRect)) {
            return binName;
          }
        }
      }

      function getTranslation(element) {
        if (element.style.transform) {
          let str = element.style.transform;
          return str
            .replace("translate3d(", "")
            .replace(/px/g, "")
            .replace(")", "")
            .split(", ")
            .map((s) => +s);
        }
      }

      function closeAllBins() {
        const bins = document.querySelectorAll(".bin");
        for (let i = 0; i < bins.length; i++) {
          let binName = bins[i].classList.toString().replace("bin", "").trim();
          bins[i].style = `url("./images/bins/${binName}Closed.png")`;
        }
      }

      function startOver() {
        inPlay = shuffle(Object.keys(items));
        score = 0;
        attempted = 0;
        onItem = 1;
        displayScore();
        currentItem = inPlay[0];
        displayItem(items[currentItem], currentItem);
        winModal.style.display = "none";
      }

      function displayItem(itemConfig, itemName) {
        itemImg.style.backgroundImage = `url("./images/${itemName}.svg")`;
        itemDes.innerHTML = toTitleCase(itemName);
      }

      function resetItemPosition() {
        itemImg.style.transform = "translate3d(0,0,0)";
        currentX = currentY = initialX = initialY = offsetX = offsetY = 0;
      }

      function setNextItem() {
        let finishedItem = inPlay.shift();
        setEmotion();

        if (inPlay.length > 0) {
          // check if game is over
          currentItem = inPlay[0];
          onItem++;
          displayScore();
          displayItem(items[currentItem], currentItem);
        } else {
          if (calculatedScore == 100)
            displayFinalScore.innerHTML = `Your final score was ${calculatedScore}% You're an Eco-warrior! Keep up the good work!`;
          else if (calculatedScore > 80)
            displayFinalScore.innerHTML = `Your final score was ${calculatedScore}% Great Job! Keep at it, and make sure to double check before you toss something!`;
          else if (calculatedScore > 40)
            displayFinalScore.innerHTML = `Your final score was ${calculatedScore}% Not bad. You may want to play again or click more info to sharpen those skills.`;
          else
            displayFinalScore.innerHTML = `Your final score was ${calculatedScore}% You absolute piece of shit. I hope you enjoy the collapse of human civilization and the extinction of life on earth.`;
          winModal.style.display = "block";
        }
      }

      function displayScore() {
        calculatedScore = Math.round((score * 100) / attempted);
        //TODO: weird line is appearing above score
        if (attempted == 0) {
          scoreEl.innerHTML = `Score:`;
        } else {
          //prettier-ignore
          scoreEl.innerHTML = `Current Score: ${calculatedScore}%`;
        }
        attemptedEl.innerHTML = `On item ${onItem} of ${totalItems}`; // TODO: Make language more elegant
      }

      function toTitleCase(str) {
        return str
          .split("-")
          .map(function (s) {
            return s.charAt(0).toUpperCase() + s.substr(1);
          })
          .join(" ");
      }

      function shuffle(elements) {
        let shuffledArr = [];
        while (elements.length > 0) {
          let idx = Math.floor(Math.random() * elements.length);
          shuffledArr.push(elements[idx]);
          elements.splice(idx, 1);
        }
        return shuffledArr;
      }

      function setItemTranslate(x, y) {
        itemImg.style.transform = `translate3d(${x}px, ${y}px, 0)`;
      }

      function displayMoreInfo() {
        if (moreInfoModal.style.display == "none")
          moreInfoModal.style.display = "block";
        else moreInfoModal.style.display = "none";
      }

      // Event Handlers
      function handleDragStart(event) {
        itemErr.innerHTML = "";
        if (event.type === "touchstart") {
          initialX = event.touches[0].clientX - offsetX;
          initialY = event.touches[0].clientY - offsetY;
        } else {
          initialX = event.clientX - offsetX;
          initialY = event.clientY - offsetY;
        }
        if (event.target.classList.contains("item") && canDrag) {
          //check if you're clicking an item AND if you may drag things
          setEmotion("surprised");
          itemImg.style.cursor = "grabbing";
          dragActive = true;
        }
      }

      function handleDrag(event) {
        if (dragActive) {
          event.preventDefault();
          if (event.type === "touchstart") {
            currentX = event.touches[0].clientX - initialX;
            currentY = event.touches[0].clientY - initialY;
          } else {
            currentX = event.clientX - initialX;
            currentY = event.clientY - initialY;
          }
          offsetX = currentX;
          offsetY = currentY;
          setItemTranslate(currentX, currentY);

          const binName = getOverlappingBin(itemImg.getBoundingClientRect());
          const testItemHeight = itemImg.getBoundingClientRect().height;

          if (binName) {
            const overlappingBin = document.querySelectorAll(`.${binName}`)[0];
            overlappingBin.style.backgroundImage = `url("./images/bins/${binName}Open.svg")`;
          } else {
            closeAllBins();
          }
        }
      }

      function handleDragEnd(event) {
        itemImg.style.cursor = "grab";
        if (canDrag) setEmotion();

        initialX = currentX;
        initialY = currentY;

        const binName = getOverlappingBin(event.target.getBoundingClientRect());
        if (
          //bin collision
          binName &&
          event.target.getBoundingClientRect().x !== 8 &&
          dragActive
        ) {
          checkSuccess(binName);
        }
        dragActive = false;
      }

      function checkSuccess(binName) {
        let correctBin = items[currentItem].bin;
        attempted++;
        lastSuccess = correctBin === binName;
        animationStartTime = Date.now();
        canDrag = false;
        if (lastSuccess) {
          //if correct bin
          setEmotion("happy");
          itemErr.innerHTML = "Hooray!";
          // TODO: itemErr.innerHTML=items[currentItem].success;
          score++;
          window.requestAnimationFrame(animateHappy);

          setTimeout(() => {
            closeAllBins();
            setNextItem();
            resetItemPosition();
            canDrag = true;
          }, animationDuration);
        } else {
          setEmotion("sad");
          itemErr.innerHTML = items[currentItem].error;
          closeAllBins();
          window.requestAnimationFrame(animateSad);

          setTimeout(() => {
            canDrag = true;
            setEmotion();
          }, animationDuration);
        }
        displayScore();
      }

      function animateHappy() {
        let jumpHeight = 7;
        let jumpSpeed = 60;
        let currentTime = Date.now();
        animationPos = currentTime - animationStartTime;
        let pos = Math.cos(animationPos / jumpSpeed) * jumpHeight;
        let currentPos = getTranslation(itemImg);
        setItemTranslate(currentPos[0], currentPos[1] + pos);
        if (currentTime < animationStartTime + animationDuration) {
          window.requestAnimationFrame(animateHappy);
        }
      }

      function animateSad() {
        let jumpHeight = 7;
        let jumpSpeed = 60;
        let currentTime = Date.now();
        animationPos = currentTime - animationStartTime;
        let pos = Math.cos(animationPos / jumpSpeed) * jumpHeight;
        let currentPos = getTranslation(itemImg);
        setItemTranslate(currentPos[0] + pos, currentPos[1]);
        if (currentTime < animationStartTime + animationDuration) {
          window.requestAnimationFrame(animateSad);
        }
      }

      function handleBinMouseEnter(event) {
        if (dragActive) {
          let element = event.target;
          let binName = element.classList.toString().replace("bin", "").trim();
          element.style.backgroundImage = `url("./images/bins/${binName}Open.svg")`;
        }
      }

      // Event Listeners
      game.addEventListener("touchstart", handleDragStart, false);
      game.addEventListener("mousedown", handleDragStart, false);
      game.addEventListener("touchmove", handleDrag, false);
      game.addEventListener("mousemove", handleDrag, false);
      game.addEventListener("touchend", handleDragEnd, false);
      game.addEventListener("mouseup", handleDragEnd, false);
    </script>
  </body>
</html>
